package com.novaflow.action.service;

import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.jayway.jsonpath.JsonPath;
import com.novaflow.action.dto.request.ActionRequest;
import com.novaflow.action.dto.response.ActionResponse;
import com.novaflow.action.dto.workflow.StepDefinition;
import com.novaflow.action.dto.workflow.StepResult;
import com.novaflow.action.dto.workflow.WorkflowDefinition;
import com.novaflow.action.dto.workflow.WorkflowRequest;
import com.novaflow.action.dto.workflow.WorkflowResult;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;

@Slf4j
@Service
@RequiredArgsConstructor
public class WorkflowExecutorService {

    private static final Pattern VARIABLE_PATTERN = Pattern.compile("\\$\\{([^}]+)}");

    private final ActionExecutorService actionExecutorService;
    private final ObjectMapper objectMapper;

    public Mono<WorkflowResult> execute(WorkflowRequest request) {
        String correlationId = StringUtils.hasText(request.getCorrelationId()) 
            ? request.getCorrelationId() 
            : UUID.randomUUID().toString();
        
        WorkflowDefinition workflow = request.getWorkflow();
        long startTime = System.currentTimeMillis();

        log.info("Starting workflow execution: {} [{}] correlation: {}", 
            workflow.getName(), workflow.getId(), correlationId);

        Map<String, Object> variables = new HashMap<>();
        if (workflow.getInputs() != null) {
            variables.putAll(workflow.getInputs());
        }
        if (request.getInputs() != null) {
            variables.putAll(request.getInputs());
        }

        List<StepResult> stepResults = new ArrayList<>();

        return executeStepsSequentially(workflow.getSteps(), variables, stepResults, correlationId, request.isDryRun())
            .map(success -> buildResult(workflow, correlationId, startTime, success, variables, stepResults))
            .onErrorResume(ex -> {
                log.error("Workflow execution failed: {}", ex.getMessage());
                return Mono.just(buildErrorResult(workflow, correlationId, startTime, ex.getMessage(), stepResults, variables));
            });
    }

    private Mono<Boolean> executeStepsSequentially(List<StepDefinition> steps, 
                                                    Map<String, Object> variables,
                                                    List<StepResult> stepResults,
                                                    String correlationId,
                                                    boolean dryRun) {
        if (steps.isEmpty()) {
            return Mono.just(true);
        }

        return executeStep(steps.get(0), variables, correlationId, dryRun)
            .flatMap(stepResult -> {
                stepResults.add(stepResult);

                if (!stepResult.isSuccess() && !stepResult.isSkipped()) {
                    StepDefinition step = steps.get(0);
                    if (step.getOnError() == StepDefinition.OnErrorAction.FAIL) {
                        log.error("Step {} failed, aborting workflow", step.getId());
                        return Mono.just(false);
                    }
                }

                if (stepResult.getExtractedVariables() != null) {
                    variables.putAll(stepResult.getExtractedVariables());
                }

                if (steps.size() > 1) {
                    return executeStepsSequentially(steps.subList(1, steps.size()), variables, stepResults, correlationId, dryRun);
                }
                return Mono.just(true);
            });
    }

    private Mono<StepResult> executeStep(StepDefinition step, Map<String, Object> variables, 
                                          String correlationId, boolean dryRun) {
        long stepStart = System.currentTimeMillis();
        log.info("Executing step: {} [{}]", step.getName(), step.getId());

        if (StringUtils.hasText(step.getSkipIf())) {
            String condition = resolveVariables(step.getSkipIf(), variables);
            if (evaluateCondition(condition)) {
                log.info("Skipping step {} due to condition: {}", step.getId(), step.getSkipIf());
                return Mono.just(StepResult.builder()
                    .stepId(step.getId())
                    .stepName(step.getName())
                    .success(true)
                    .skipped(true)
                    .durationMs(System.currentTimeMillis() - stepStart)
                    .build());
            }
        }

        try {
            String actionRequestJson = objectMapper.writeValueAsString(step.getActionRequest());
            String resolvedJson = resolveVariables(actionRequestJson, variables);
            
            ActionRequest actionRequest = objectMapper.readValue(resolvedJson, ActionRequest.class);
            
            if (actionRequest.getRequest() != null) {
                actionRequest.getRequest().setCorrelationId(correlationId);
                actionRequest.getRequest().setDryRun(dryRun);
            }

            return executeWithRetry(actionRequest, step.getRetryCount(), step.getRetryDelayMs())
                .map(response -> buildStepResult(step, stepStart, response, variables));

        } catch (Exception e) {
            log.error("Failed to prepare step {}: {}", step.getId(), e.getMessage());
            return Mono.just(StepResult.builder()
                .stepId(step.getId())
                .stepName(step.getName())
                .success(false)
                .error("Failed to prepare request: " + e.getMessage())
                .durationMs(System.currentTimeMillis() - stepStart)
                .build());
        }
    }

    private Mono<ActionResponse> executeWithRetry(ActionRequest request, int retryCount, int retryDelayMs) {
        return actionExecutorService.execute(request)
            .flatMap(response -> {
                if (!response.isSuccess() && retryCount > 0) {
                    log.warn("Step failed, retrying... ({} attempts left)", retryCount);
                    return Mono.delay(java.time.Duration.ofMillis(retryDelayMs))
                        .flatMap(tick -> executeWithRetry(request, retryCount - 1, retryDelayMs));
                }
                return Mono.just(response);
            });
    }

    private StepResult buildStepResult(StepDefinition step, long stepStart, 
                                        ActionResponse response, Map<String, Object> variables) {
        Map<String, Object> extractedVars = new HashMap<>();

        if (response.isSuccess() && step.getExtract() != null && response.getRawResponse() != null) {
            for (StepDefinition.VariableExtraction extraction : step.getExtract()) {
                try {
                    Object value = extractValue(extraction, response);
                    if (value != null) {
                        extractedVars.put(extraction.getName(), value);
                        log.debug("Extracted variable {}: {}", extraction.getName(), 
                            value.toString().length() > 100 ? value.toString().substring(0, 100) + "..." : value);
                    } else if (extraction.getDefaultValue() != null) {
                        extractedVars.put(extraction.getName(), extraction.getDefaultValue());
                    }
                } catch (Exception e) {
                    log.warn("Failed to extract variable {}: {}", extraction.getName(), e.getMessage());
                    if (extraction.getDefaultValue() != null) {
                        extractedVars.put(extraction.getName(), extraction.getDefaultValue());
                    }
                }
            }
        }

        Integer statusCode = null;
        if (response.getRawResponse() != null) {
            statusCode = response.getRawResponse().getStatus();
        }

        return StepResult.builder()
            .stepId(step.getId())
            .stepName(step.getName())
            .success(response.isSuccess())
            .statusCode(statusCode)
            .durationMs(System.currentTimeMillis() - stepStart)
            .extractedVariables(extractedVars)
            .error(response.getError() != null ? response.getError().getMessage() : null)
            .rawResponse(response.getRawResponse())
            .build();
    }

    private Object extractValue(StepDefinition.VariableExtraction extraction, ActionResponse response) {
        if (StringUtils.hasText(extraction.getJsonPath())) {
            Object body = response.getRawResponse().getBody();
            if (body != null) {
                Object jsonContent = null;
                if (body instanceof com.novaflow.action.dto.response.ResponseBody responseBody) {
                    jsonContent = responseBody.getJson();
                    if (jsonContent == null && responseBody.getText() != null) {
                        try {
                            jsonContent = objectMapper.readValue(responseBody.getText(), Object.class);
                        } catch (Exception e) {
                            return null;
                        }
                    }
                }
                if (jsonContent != null) {
                    String jsonString;
                    try {
                        jsonString = objectMapper.writeValueAsString(jsonContent);
                        return JsonPath.read(jsonString, extraction.getJsonPath());
                    } catch (Exception e) {
                        log.warn("JSONPath extraction failed: {}", e.getMessage());
                        return null;
                    }
                }
            }
        }

        if (StringUtils.hasText(extraction.getHeader())) {
            Map<String, String> headers = response.getRawResponse().getHeaders();
            if (headers != null) {
                return headers.get(extraction.getHeader());
            }
        }

        return null;
    }

    private String resolveVariables(String template, Map<String, Object> variables) {
        if (template == null || !template.contains("${")) {
            return template;
        }

        StringBuffer result = new StringBuffer();
        Matcher matcher = VARIABLE_PATTERN.matcher(template);

        while (matcher.find()) {
            String varName = matcher.group(1);
            Object value = variables.get(varName);
            String replacement = value != null ? escapeJsonValue(value.toString()) : "";
            matcher.appendReplacement(result, Matcher.quoteReplacement(replacement));
        }
        matcher.appendTail(result);

        return result.toString();
    }

    private String escapeJsonValue(String value) {
        return value.replace("\\", "\\\\")
                   .replace("\"", "\\\"")
                   .replace("\n", "\\n")
                   .replace("\r", "\\r")
                   .replace("\t", "\\t");
    }

    private boolean evaluateCondition(String condition) {
        if (!StringUtils.hasText(condition)) {
            return false;
        }
        String trimmed = condition.trim().toLowerCase();
        return "true".equals(trimmed) || "1".equals(trimmed);
    }

    private WorkflowResult buildResult(WorkflowDefinition workflow, String correlationId,
                                        long startTime, boolean success,
                                        Map<String, Object> variables, List<StepResult> stepResults) {
        String failedStep = null;
        int completedSteps = 0;
        
        for (StepResult sr : stepResults) {
            if (sr.isSuccess() || sr.isSkipped()) {
                completedSteps++;
            } else {
                failedStep = sr.getStepId();
                break;
            }
        }

        return WorkflowResult.builder()
            .workflowId(workflow.getId())
            .workflowName(workflow.getName())
            .correlationId(correlationId)
            .timestamp(Instant.now())
            .success(success && failedStep == null)
            .totalSteps(workflow.getSteps().size())
            .completedSteps(completedSteps)
            .failedStep(failedStep)
            .durationMs(System.currentTimeMillis() - startTime)
            .variables(variables)
            .stepResults(stepResults)
            .build();
    }

    private WorkflowResult buildErrorResult(WorkflowDefinition workflow, String correlationId,
                                             long startTime, String error,
                                             List<StepResult> stepResults, Map<String, Object> variables) {
        return WorkflowResult.builder()
            .workflowId(workflow.getId())
            .workflowName(workflow.getName())
            .correlationId(correlationId)
            .timestamp(Instant.now())
            .success(false)
            .totalSteps(workflow.getSteps().size())
            .completedSteps(stepResults.size())
            .durationMs(System.currentTimeMillis() - startTime)
            .variables(variables)
            .stepResults(stepResults)
            .error(error)
            .build();
 