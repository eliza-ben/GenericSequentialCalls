

package com.novaflow.action.service;

import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicLong;

import org.springframework.core.io.ByteArrayResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.http.client.MultipartBodyBuilder;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.util.StringUtils;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.ClientResponse;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.util.UriComponentsBuilder;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.novaflow.action.config.ActionProperties;
import com.novaflow.action.dto.request.ActionRequest;
import com.novaflow.action.dto.request.ApiConfig;
import com.novaflow.action.dto.request.ApiConfig.PayloadType;
import com.novaflow.action.dto.request.AuthConfig;
import com.novaflow.action.dto.request.FileInputConfig;
import com.novaflow.action.dto.request.FileOutputConfig;
import com.novaflow.action.dto.response.ActionResponse;
import com.novaflow.action.dto.response.Metrics;
import com.novaflow.action.dto.response.RawResponse;
import com.novaflow.action.dto.response.ResponseBody;
import com.novaflow.action.dto.response.ResponseBody.BodyMode;
import com.novaflow.action.dto.response.TokenCallInfo;
import com.novaflow.action.exception.ActionException;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;

@Slf4j
@Service
@RequiredArgsConstructor
public class ActionExecutorService {

    private final WebClient.Builder webClientBuilder;
    private final ActionProperties properties;
    private final OAuthTokenService oAuthTokenService;
    private final OutboundSecurityService securityService;
    private final FileService fileService;
    private final ResponseExtractionService extractionService;
    private final ObjectMapper objectMapper;

    public Mono<ActionResponse> execute(ActionRequest request) {
        String requestId = UUID.randomUUID().toString();
        String correlationId = resolveCorrelationId(request);
        long startTime = System.currentTimeMillis();
        AtomicLong tokenFetchMs = new AtomicLong(0);
        AtomicLong bytesSent = new AtomicLong(0);
        AtomicLong bytesReceived = new AtomicLong(0);

        log.info("Executing action request: {} correlation: {}", requestId, correlationId);

        if (request.getRequest() != null && request.getRequest().isDryRun()) {
            return handleDryRun(requestId, correlationId, request);
        }

        ApiConfig api = request.getApi();
        validateRequest(api);

        int timeout = Math.min(api.getRequestTimeoutSec(), properties.getLimits().getMaxTimeoutSec());

        return oAuthTokenService.getToken(request.getAuthConfig(), timeout)
            .doOnNext(tokenResult -> {
                if (tokenResult.tokenCallInfo().isUsed() && !tokenResult.tokenCallInfo().isCached()) {
                    tokenFetchMs.set(System.currentTimeMillis() - startTime);
                }
            })
            .flatMap(tokenResult -> 
                executeTargetCall(request, tokenResult.accessToken(), correlationId, timeout, bytesSent, bytesReceived)
                    .map(rawResponse -> buildResponse(requestId, correlationId, startTime, 
                        tokenResult.tokenCallInfo(), rawResponse, request, 
                        tokenFetchMs.get(), bytesSent.get(), bytesReceived.get()))
            )
            .onErrorResume(ex -> handleError(requestId, correlationId, startTime, ex));
    }

    private void validateRequest(ApiConfig api) {
        securityService.validateUrl(api.getUrl());
        securityService.validateMethod(api.getMethod());
        
        if (isBodylessMethod(api.getMethod()) && api.getPayloadType() != PayloadType.NONE) {
            if (api.getPayloadType() != null && api.getPayloadType() != PayloadType.NONE) {
                log.warn("Method {} should not have a payload, ignoring payload_type", api.getMethod());
            }
        }
    }

    private boolean isBodylessMethod(ApiConfig.HttpMethod method) {
        return method == ApiConfig.HttpMethod.GET || 
               method == ApiConfig.HttpMethod.HEAD || 
               method == ApiConfig.HttpMethod.OPTIONS;
    }

    private String resolveCorrelationId(ActionRequest request) {
        if (request.getRequest() != null && StringUtils.hasText(request.getRequest().getCorrelationId())) {
            return request.getRequest().getCorrelationId();
        }
        return UUID.randomUUID().toString();
    }

    private Mono<ActionResponse> handleDryRun(String requestId, String correlationId, ActionRequest request) {
        log.info("Dry run mode - validating request without execution");
        
        return Mono.just(ActionResponse.builder()
            .requestId(requestId)
            .timestamp(Instant.now())
            .success(true)
            .correlationId(correlationId)
            .tokenCall(TokenCallInfo.builder().used(false).build())
            .rawResponse(RawResponse.builder()
                .status(0)
                .body(ResponseBody.builder()
                    .mode(BodyMode.TEXT)
                    .text("DRY_RUN - Request validated successfully")
                    .build())
                .build())
            .metrics(Metrics.builder().durationMs(0).build())
            .build());
    }

    private Mono<RawResponse> executeTargetCall(ActionRequest request, String accessToken, 
                                                  String correlationId, int timeout,
                                                  AtomicLong bytesSent, AtomicLong bytesReceived) {
        ApiConfig api = request.getApi();
        
        String url = buildUrl(api, correlationId);
        log.debug("Target URL: {}", url);

        return fileService.loadFileInput(request.getFileInput())
            .defaultIfEmpty(new FileService.FileContent(null, null, null))
            .flatMap(fileContent -> {
                WebClient.RequestBodySpec requestSpec = webClientBuilder.build()
                    .method(HttpMethod.valueOf(api.getMethod().name()))
                    .uri(url);

                addHeaders(requestSpec, api, accessToken, correlationId);

                WebClient.RequestHeadersSpec<?> finalSpec = addBody(requestSpec, api, fileContent, bytesSent);

                return finalSpec
                    .exchangeToMono(response -> handleResponse(response, request.getFileOutput(), 
                        request.getResponseHandling(), bytesReceived))
                    .timeout(Duration.ofSeconds(timeout))
                    .onErrorMap(ex -> {
                        if (ex instanceof java.util.concurrent.TimeoutException) {
                            return new ActionException("TIMEOUT", "Request timed out after " + timeout + " seconds");
                        }
                        return ex;
                    });
            });
    }

    private String buildUrl(ApiConfig api, String correlationId) {
        UriComponentsBuilder builder = UriComponentsBuilder.fromUriString(api.getUrl());
        
        if (api.getQuery() != null) {
            api.getQuery().forEach(builder::queryParam);
        }
        
        if (api.isIncludeCorrelationId()) {
            builder.queryParam("correlation_id", correlationId);
        }
        
        if (api.isIncludeAsofDate()) {
            String asofDate = api.getAsofDate() != null ? api.getAsofDate() : 
                LocalDate.now().format(DateTimeFormatter.ISO_LOCAL_DATE);
            builder.queryParam("asof_date", asofDate);
        }
        
        return builder.build().toUriString();
    }

    private void addHeaders(WebClient.RequestBodySpec requestSpec, ApiConfig api, 
                           String accessToken, String correlationId) {
        if (api.getHeaders() != null) {
            api.getHeaders().forEach((name, value) -> {
                if (!securityService.isHeaderForbidden(name)) {
                    requestSpec.header(name, value);
                } else {
                    log.debug("Skipping forbidden header: {}", name);
                }
            });
        }

        if (StringUtils.hasText(accessToken)) {
            requestSpec.header(HttpHeaders.AUTHORIZATION, "Bearer " + accessToken);
        } else if (StringUtils.hasText(api.getBearerToken())) {
            requestSpec.header(HttpHeaders.AUTHORIZATION, "Bearer " + api.getBearerToken());
        } else if (api.getBasicAuth() != null && 
                   StringUtils.hasText(api.getBasicAuth().getUsername())) {
            String credentials = api.getBasicAuth().getUsername() + ":" + api.getBasicAuth().getPassword();
            String encoded = Base64.getEncoder().encodeToString(credentials.getBytes(StandardCharsets.UTF_8));
            requestSpec.header(HttpHeaders.AUTHORIZATION, "Basic " + encoded);
        } else if (StringUtils.hasText(api.getCredentialRef())) {
            ActionProperties.CredentialEntry cred = properties.getCredentials().get(api.getCredentialRef());
            if (cred != null && StringUtils.hasText(cred.getUsername())) {
                String credentials = cred.getUsername() + ":" + cred.getPassword();
                String encoded = Base64.getEncoder().encodeToString(credentials.getBytes(StandardCharsets.UTF_8));
                requestSpec.header(HttpHeaders.AUTHORIZATION, "Basic " + encoded);
            }
        }

        if (api.isIncludeCorrelationId()) {
            requestSpec.header("X-Correlation-ID", correlationId);
        }
    }

    private WebClient.RequestHeadersSpec<?> addBody(WebClient.RequestBodySpec requestSpec, 
                                                      ApiConfig api, 
                                                      FileService.FileContent fileContent,
                                                      AtomicLong bytesSent) {
        PayloadType payloadType = api.getPayloadType() != null ? api.getPayloadType() : PayloadType.NONE;
        
        if (isBodylessMethod(api.getMethod())) {
            return requestSpec;
        }

        return switch (payloadType) {
            case JSON -> {
                if (api.getPayload() != null) {
                    try {
                        byte[] jsonBytes = objectMapper.writeValueAsBytes(api.getPayload());
                        bytesSent.set(jsonBytes.length);
                        yield requestSpec
                            .contentType(MediaType.APPLICATION_JSON)
                            .bodyValue(api.getPayload());
                    } catch (JsonProcessingException e) {
                        throw new ActionException("PAYLOAD_INVALID", "Failed to serialize JSON payload");
                    }
                }
                yield requestSpec;
            }
            case TEXT -> {
                if (StringUtils.hasText(api.getPayloadText())) {
                    byte[] textBytes = api.getPayloadText().getBytes(StandardCharsets.UTF_8);
                    bytesSent.set(textBytes.length);
                    yield requestSpec
                        .contentType(MediaType.TEXT_PLAIN)
                        .bodyValue(api.getPayloadText());
                }
                yield requestSpec;
            }
            case FORM_URLENCODED -> {
                if (api.getPayload() instanceof Map) {
                    @SuppressWarnings("unchecked")
                    Map<String, Object> payload = (Map<String, Object>) api.getPayload();
                    MultiValueMap<String, String> formData = new LinkedMultiValueMap<>();
                    payload.forEach((k, v) -> formData.add(k, String.valueOf(v)));
                    yield requestSpec
                        .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                        .body(BodyInserters.fromFormData(formData));
                }
                yield requestSpec;
            }
            case MULTIPART_FORM -> {
                MultipartBodyBuilder builder = new MultipartBodyBuilder();
                
                if (api.getPayload() instanceof Map) {
                    @SuppressWarnings("unchecked")
                    Map<String, Object> payload = (Map<String, Object>) api.getPayload();
                    payload.forEach((k, v) -> builder.part(k, String.valueOf(v)));
                }
                
                if (fileContent.bytes() != null) {
                    String filename = fileContent.filename() != null ? fileContent.filename() : "file";
                    String contentType = fileContent.contentType() != null ? fileContent.contentType() : "application/octet-stream";
                    bytesSent.addAndGet(fileContent.bytes().length);
                    builder.part("file", new ByteArrayResource(fileContent.bytes()) {
                        @Override
                        public String getFilename() {
                            return filename;
                        }
                    }).contentType(MediaType.parseMediaType(contentType));
                }
                
                yield requestSpec
                    .contentType(MediaType.MULTIPART_FORM_DATA)
                    .body(BodyInserters.fromMultipartData(builder.build()));
            }
            case FILE_BYTES -> {
                if (fileContent.bytes() != null) {
                    bytesSent.set(fileContent.bytes().length);
                    String contentType = fileContent.contentType() != null ? fileContent.contentType() : "application/octet-stream";
                    yield requestSpec
                        .contentType(MediaType.parseMediaType(contentType))
                        .bodyValue(fileContent.bytes());
                }
                throw new ActionException("FILE_MISSING", "FILE_BYTES payload type requires file_input");
            }
            case NONE -> requestSpec;
        };
    }

    private Mono<RawResponse> handleResponse(ClientResponse response, FileOutputConfig fileOutput,
                                              com.novaflow.action.dto.request.ResponseHandlingConfig responseHandling,
                                              AtomicLong bytesReceived) {
        int status = response.statusCode().value();
        Map<String, String> headers = new HashMap<>();
        response.headers().asHttpHeaders().forEach((name, values) -> {
            if (!values.isEmpty()) {
                headers.put(name, values.get(0));
            }
        });

        long contentLength = response.headers().contentLength().orElse(-1);
        long maxBytes = properties.getLimits().getMaxResponseBytes();

        if (fileOutput != null && fileOutput.getMode() == FileOutputConfig.FileOutputMode.STREAM_TO_FILE) {
            return fileService.saveToFile(fileOutput, response.bodyToFlux(org.springframework.core.io.buffer.DataBuffer.class))
                .map(savedFile -> {
                    bytesReceived.set(savedFile.getSizeBytes() != null ? savedFile.getSizeBytes() : 0);
                    return RawResponse.builder()
                        .status(status)
                        .headers(headers)
                        .body(ResponseBody.builder()
                            .mode(BodyMode.STREAMED_TO_FILE)
                            .savedFile(savedFile)
                            .build())
                        .build();
                });
        }

        if (contentLength > maxBytes) {
            return response.releaseBody()
                .thenReturn(RawResponse.builder()
                    .status(status)
                    .headers(headers)
                    .body(ResponseBody.builder()
                        .mode(BodyMode.OMITTED_TOO_LARGE)
                        .text("Response too large: " + contentLength + " bytes")
                        .build())
                    .build());
        }

        return response.bodyToMono(byte[].class)
            .defaultIfEmpty(new byte[0])
            .map(bodyBytes -> {
                bytesReceived.set(bodyBytes.length);
                return buildResponseBody(bodyBytes, headers, responseHandling);
            })
            .map(body -> RawResponse.builder()
                .status(status)
                .headers(headers)
                .body(body)
                .build());
    }

    private ResponseBody buildResponseBody(byte[] bodyBytes, Map<String, String> headers,
                                            com.novaflow.action.dto.request.ResponseHandlingConfig responseHandling) {
        String contentType = headers.getOrDefault("Content-Type", "");
        String bodyText = new String(bodyBytes, StandardCharsets.UTF_8);

        if (contentType.contains("application/json")) {
            try {
                Object json = objectMapper.readValue(bodyBytes, Object.class);
                return ResponseBody.builder()
                    .mode(BodyMode.JSON)
                    .json(json)
                    .build();
            } catch (Exception e) {
                log.debug("Failed to parse JSON response: {}", e.getMessage());
            }
        }

        if (contentType.contains("text/") || contentType.contains("application/xml")) {
            return ResponseBody.builder()
                .mode(BodyMode.TEXT)
                .text(bodyText)
                .build();
        }

        return ResponseBody.builder()
            .mode(BodyMode.BASE64)
            .base64(Base64.getEncoder().encodeToString(bodyBytes))
            .build();
    }

    private ActionResponse buildResponse(String requestId, String correlationId, long startTime,
                                          TokenCallInfo tokenCall, RawResponse rawResponse,
                                          ActionRequest request, long tokenFetchMs,
                                          long bytesSent, long bytesReceived) {
        Map<String, Object> parsedOutput = new HashMap<>();
        
        if (request.getResponseHandling() != null && request.getResponseHandling().isParse()) {
            String bodyText = extractBodyText(rawResponse);
            parsedOutput = extractionService.extract(
                request.getResponseHandling(),
                rawResponse.getStatus(),
                rawResponse.getHeaders(),
                bodyText
            );
        }

        long totalDuration = System.currentTimeMillis() - startTime;

        return ActionResponse.builder()
            .requestId(requestId)
            .timestamp(Instant.now())
            .success(true)
            .correlationId(correlationId)
            .tokenCall(tokenCall)
            .rawResponse(rawResponse)
            .parsedOutput(parsedOutput.isEmpty() ? null : parsedOutput)
            .metrics(Metrics.builder()
                .durationMs(totalDuration)
                .tokenFetchMs(tokenFetchMs > 0 ? tokenFetchMs : null)
                .targetCallMs(totalDuration - tokenFetchMs)
                .bytesSent(bytesSent)
                .bytesReceived(bytesReceived)
                .build())
            .build();
    }

    private String extractBodyText(RawResponse rawResponse) {
        if (rawResponse.getBody() == null) {
            return null;
        }
        
        ResponseBody body = rawResponse.getBody();
        
        if (body.getJson() != null) {
            try {
                return objectMapper.writeValueAsString(body.getJson());
            } catch (JsonProcessingException e) {
                return null;
            }
        }
        
        return body.getText();
    }

    private Mono<ActionResponse> handleError(String requestId, String correlationId, 
                                              long startTime, Throwable ex) {
        log.error("Action execution failed: {}", ex.getMessage());
        
        String code = "EXECUTION_FAILED";
        String message = ex.getMessage();
        
        if (ex instanceof ActionException actionEx) {
            code = actionEx.getCode();
        }

        return Mono.just(ActionResponse.builder()
            .requestId(requestId)
            .timestamp(Instant.now())
            .success(false)
            .correlationId(correlationId)
            .error(com.novaflow.action.dto.response.ErrorInfo.builder()
                .code(code)
                .message(message)
                .build())
            .metrics(Metrics.builder()
                .durationMs(System.currentTimeMillis() - startTime)
                .build())
            .build());
    }
}
