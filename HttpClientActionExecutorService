package com.novaflow.action.service;

import java.net.URI;
import java.net.URLEncoder;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.time.Instant;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicLong;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import org.springframework.web.util.UriComponentsBuilder;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.novaflow.action.config.ActionProperties;
import com.novaflow.action.dto.request.ActionRequest;
import com.novaflow.action.dto.request.ApiConfig;
import com.novaflow.action.dto.request.ApiConfig.PayloadType;
import com.novaflow.action.dto.request.FileOutputConfig;
import com.novaflow.action.dto.response.ActionResponse;
import com.novaflow.action.dto.response.ErrorInfo;
import com.novaflow.action.dto.response.Metrics;
import com.novaflow.action.dto.response.RawResponse;
import com.novaflow.action.dto.response.ResponseBody;
import com.novaflow.action.dto.response.ResponseBody.BodyMode;
import com.novaflow.action.dto.response.TokenCallInfo;
import com.novaflow.action.exception.ActionException;

import lombok.extern.Slf4j;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

@Slf4j
@Service("httpClientExecutor")
public class HttpClientActionExecutorService implements ActionExecutor {

    private final ActionProperties properties;
    private final OAuthTokenService oAuthTokenService;
    private final OutboundSecurityService securityService;
    private final FileService fileService;
    private final ResponseExtractionService extractionService;
    private final ObjectMapper objectMapper;

    private final HttpClient httpClient = HttpClient.newBuilder()
            .followRedirects(HttpClient.Redirect.NORMAL)
            .connectTimeout(Duration.ofSeconds(10))
            .build();

    public HttpClientActionExecutorService(ActionProperties properties,
                                            OAuthTokenService oAuthTokenService,
                                            OutboundSecurityService securityService,
                                            FileService fileService,
                                            ResponseExtractionService extractionService,
                                            ObjectMapper objectMapper) {
        this.properties = properties;
        this.oAuthTokenService = oAuthTokenService;
        this.securityService = securityService;
        this.fileService = fileService;
        this.extractionService = extractionService;
        this.objectMapper = objectMapper;
    }

    @Override
    public Mono<ActionResponse> execute(ActionRequest request) {
        String requestId = UUID.randomUUID().toString();
        String correlationId = resolveCorrelationId(request);
        long startTime = System.currentTimeMillis();
        AtomicLong tokenFetchMs = new AtomicLong(0);
        AtomicLong bytesSent = new AtomicLong(0);
        AtomicLong bytesReceived = new AtomicLong(0);

        log.info("[HttpClient] Executing action: {} correlation: {}", requestId, correlationId);

        if (request.getRequest() != null && request.getRequest().isDryRun()) {
            return handleDryRun(requestId, correlationId);
        }

        ApiConfig api = request.getApi();
        validateRequest(api);

        int timeout = Math.min(api.getRequestTimeoutSec(), properties.getLimits().getMaxTimeoutSec());

        return oAuthTokenService.getToken(api.isPresignedUrl() ? null : request.getAuthConfig(), timeout)
                .doOnNext(tokenResult -> {
                    if (tokenResult.tokenCallInfo().isUsed() && !tokenResult.tokenCallInfo().isCached()) {
                        tokenFetchMs.set(System.currentTimeMillis() - startTime);
                    }
                })
                .flatMap(tokenResult ->
                        Mono.fromCallable(() ->
                                executeTargetCall(request, tokenResult.accessToken(),
                                        correlationId, timeout, bytesSent, bytesReceived)
                        )
                        .subscribeOn(Schedulers.boundedElastic())
                        .map(rawResponse -> buildResponse(requestId, correlationId, startTime,
                                tokenResult.tokenCallInfo(), rawResponse, request,
                                tokenFetchMs.get(), bytesSent.get(), bytesReceived.get()))
                )
                .onErrorResume(ex -> handleError(requestId, correlationId, startTime, ex));
    }

    // -------------------------------------------------------------------------
    // Core HTTP call (blocking)
    // -------------------------------------------------------------------------

    private RawResponse executeTargetCall(ActionRequest request, String accessToken,
                                           String correlationId, int timeout,
                                           AtomicLong bytesSent, AtomicLong bytesReceived) throws Exception {
        ApiConfig api = request.getApi();
        String url = buildUrl(api, correlationId);
        log.debug("[HttpClient] Target URL: {}", url);

        FileService.FileContent fileContent = fileService.loadFileInput(request.getFileInput())
                .blockOptional()
                .orElse(new FileService.FileContent(null, null, null));

        // Resolve multipart boundary before building request so we can set Content-Type header
        String multipartBoundary = null;
        if (api.getPayloadType() == PayloadType.MULTIPART_FORM) {
            multipartBoundary = UUID.randomUUID().toString();
        }

        HttpRequest.BodyPublisher bodyPublisher = buildBodyPublisher(api, fileContent, bytesSent, multipartBoundary);

        HttpRequest.Builder requestBuilder = HttpRequest.newBuilder()
                .uri(URI.create(url))
                .timeout(Duration.ofSeconds(timeout))
                .method(api.getMethod().name(), bodyPublisher);

        addHeaders(requestBuilder, api, accessToken, correlationId, fileContent, multipartBoundary);

        HttpResponse<byte[]> response = httpClient.send(requestBuilder.build(),
                HttpResponse.BodyHandlers.ofByteArray());

        return processResponse(response, request.getFileOutput(), bytesReceived);
    }

    // -------------------------------------------------------------------------
    // URL
    // -------------------------------------------------------------------------

    private String buildUrl(ApiConfig api, String correlationId) {
        UriComponentsBuilder builder = UriComponentsBuilder.fromUriString(api.getUrl());

        if (api.getQuery() != null) {
            api.getQuery().forEach(builder::queryParam);
        }

        if (!api.isPresignedUrl()) {
            if (api.isIncludeCorrelationId()) {
                builder.queryParam("correlation_id", correlationId);
            }
            if (api.isIncludeAsofDate()) {
                String asofDate = api.getAsofDate() != null ? api.getAsofDate() :
                        LocalDate.now().format(DateTimeFormatter.ISO_LOCAL_DATE);
                builder.queryParam("asof_date", asofDate);
            }
        }

        return builder.build().toUriString();
    }

    // -------------------------------------------------------------------------
    // Headers
    // -------------------------------------------------------------------------

    private void addHeaders(HttpRequest.Builder requestBuilder, ApiConfig api,
                             String accessToken, String correlationId,
                             FileService.FileContent fileContent, String multipartBoundary) {
        // Content-Type based on payload type
        if (!isBodylessMethod(api.getMethod())) {
            switch (api.getPayloadType() != null ? api.getPayloadType() : PayloadType.NONE) {
                case JSON -> requestBuilder.header("Content-Type", "application/json");
                case TEXT -> requestBuilder.header("Content-Type", "text/plain");
                case FORM_URLENCODED -> requestBuilder.header("Content-Type", "application/x-www-form-urlencoded");
                case MULTIPART_FORM -> requestBuilder.header("Content-Type",
                        "multipart/form-data; boundary=" + multipartBoundary);
                case FILE_BYTES -> {
                    String ct = fileContent.contentType() != null
                            ? fileContent.contentType() : "application/octet-stream";
                    requestBuilder.header("Content-Type", ct);
                }
                default -> { }
            }
        }

        // Custom headers (may override Content-Type above)
        if (api.getHeaders() != null) {
            api.getHeaders().forEach((name, value) -> {
                if (!securityService.isHeaderForbidden(name)) {
                    requestBuilder.header(name, value);
                } else {
                    log.debug("Skipping forbidden header: {}", name);
                }
            });
        }

        // Auth — skipped entirely for presigned URLs
        if (!api.isPresignedUrl()) {
            if (StringUtils.hasText(accessToken)) {
                requestBuilder.header("Authorization", "Bearer " + accessToken);
            } else if (StringUtils.hasText(api.getBearerToken())) {
                requestBuilder.header("Authorization", "Bearer " + api.getBearerToken());
            } else if (api.getBasicAuth() != null &&
                       StringUtils.hasText(api.getBasicAuth().getUsername())) {
                requestBuilder.header("Authorization",
                        buildBasicAuth(api.getBasicAuth().getUsername(), api.getBasicAuth().getPassword()));
            } else if (StringUtils.hasText(api.getCredentialRef())) {
                ActionProperties.CredentialEntry cred =
                        properties.getCredentials().get(api.getCredentialRef());
                if (cred != null && StringUtils.hasText(cred.getUsername())) {
                    requestBuilder.header("Authorization",
                            buildBasicAuth(cred.getUsername(), cred.getPassword()));
                }
            }

            if (api.isIncludeCorrelationId()) {
                requestBuilder.header("X-Correlation-ID", correlationId);
            }
        }
    }

    private String buildBasicAuth(String username, String password) {
        return "Basic " + Base64.getEncoder()
                .encodeToString((username + ":" + password).getBytes(StandardCharsets.UTF_8));
    }

    // -------------------------------------------------------------------------
    // Body publisher
    // -------------------------------------------------------------------------

    private HttpRequest.BodyPublisher buildBodyPublisher(ApiConfig api,
                                                          FileService.FileContent fileContent,
                                                          AtomicLong bytesSent,
                                                          String multipartBoundary) throws JsonProcessingException {
        PayloadType payloadType = api.getPayloadType() != null ? api.getPayloadType() : PayloadType.NONE;

        if (isBodylessMethod(api.getMethod())) {
            return HttpRequest.BodyPublishers.noBody();
        }

        return switch (payloadType) {
            case JSON -> {
                if (api.getPayload() != null) {
                    byte[] bytes = objectMapper.writeValueAsBytes(api.getPayload());
                    bytesSent.set(bytes.length);
                    yield HttpRequest.BodyPublishers.ofByteArray(bytes);
                }
                yield HttpRequest.BodyPublishers.noBody();
            }
            case TEXT -> {
                if (StringUtils.hasText(api.getPayloadText())) {
                    byte[] bytes = api.getPayloadText().getBytes(StandardCharsets.UTF_8);
                    bytesSent.set(bytes.length);
                    yield HttpRequest.BodyPublishers.ofByteArray(bytes);
                }
                yield HttpRequest.BodyPublishers.noBody();
            }
            case FORM_URLENCODED -> {
                if (api.getPayload() instanceof Map<?, ?> map) {
                    StringBuilder sb = new StringBuilder();
                    map.forEach((k, v) -> {
                        if (!sb.isEmpty()) sb.append('&');
                        sb.append(urlEncode(k.toString()))
                          .append('=')
                          .append(urlEncode(v.toString()));
                    });
                    byte[] bytes = sb.toString().getBytes(StandardCharsets.UTF_8);
                    bytesSent.set(bytes.length);
                    yield HttpRequest.BodyPublishers.ofByteArray(bytes);
                }
                yield HttpRequest.BodyPublishers.noBody();
            }
            case MULTIPART_FORM -> {
                byte[] bytes = buildMultipartBody(api, fileContent, multipartBoundary, bytesSent);
                yield HttpRequest.BodyPublishers.ofByteArray(bytes);
            }
            case FILE_BYTES -> {
                if (fileContent.bytes() == null) {
                    throw new ActionException("FILE_MISSING", "FILE_BYTES payload requires file_input");
                }
                bytesSent.set(fileContent.bytes().length);
                yield HttpRequest.BodyPublishers.ofByteArray(fileContent.bytes());
            }
            case NONE -> HttpRequest.BodyPublishers.noBody();
        };
    }

    private byte[] buildMultipartBody(ApiConfig api, FileService.FileContent fileContent,
                                       String boundary, AtomicLong bytesSent) {
        final String CRLF = "\r\n";
        var parts = new java.io.ByteArrayOutputStream();

        try {
            // Text fields
            if (api.getPayload() instanceof Map<?, ?> map) {
                for (var entry : map.entrySet()) {
                    String part = "--" + boundary + CRLF +
                            "Content-Disposition: form-data; name=\"" + entry.getKey() + "\"" + CRLF +
                            CRLF +
                            entry.getValue() + CRLF;
                    parts.write(part.getBytes(StandardCharsets.UTF_8));
                }
            }

            // File part
            if (fileContent.bytes() != null) {
                String filename = fileContent.filename() != null ? fileContent.filename() : "file";
                String ct = fileContent.contentType() != null ? fileContent.contentType() : "application/octet-stream";
                String header = "--" + boundary + CRLF +
                        "Content-Disposition: form-data; name=\"file\"; filename=\"" + filename + "\"" + CRLF +
                        "Content-Type: " + ct + CRLF + CRLF;
                parts.write(header.getBytes(StandardCharsets.UTF_8));
                parts.write(fileContent.bytes());
                parts.write(CRLF.getBytes(StandardCharsets.UTF_8));
            }

            // Closing boundary
            parts.write(("--" + boundary + "--" + CRLF).getBytes(StandardCharsets.UTF_8));

        } catch (Exception e) {
            throw new ActionException("MULTIPART_BUILD_FAILED", "Failed to build multipart body: " + e.getMessage());
        }

        byte[] result = parts.toByteArray();
        bytesSent.set(result.length);
        return result;
    }

    // -------------------------------------------------------------------------
    // Response processing
    // -------------------------------------------------------------------------

    private RawResponse processResponse(HttpResponse<byte[]> response,
                                         FileOutputConfig fileOutput,
                                         AtomicLong bytesReceived) {
        int status = response.statusCode();
        Map<String, String> headers = new HashMap<>();
        // HttpClient returns lowercase header names — normalize to match WebClient behaviour
        response.headers().map().forEach((name, values) -> {
            if (!values.isEmpty()) headers.put(name, values.get(0));
        });

        byte[] bodyBytes = response.body() != null ? response.body() : new byte[0];
        bytesReceived.set(bodyBytes.length);

        long maxBytes = properties.getLimits().getMaxResponseBytes();
        if (bodyBytes.length > maxBytes) {
            return RawResponse.builder()
                    .status(status)
                    .headers(headers)
                    .body(ResponseBody.builder()
                            .mode(BodyMode.OMITTED_TOO_LARGE)
                            .text("Response too large: " + bodyBytes.length + " bytes")
                            .build())
                    .build();
        }

        return RawResponse.builder()
                .status(status)
                .headers(headers)
                .body(buildResponseBody(bodyBytes, headers))
                .build();
    }

    private ResponseBody buildResponseBody(byte[] bodyBytes, Map<String, String> headers) {
        // HttpClient headers are lowercase
        String contentType = headers.getOrDefault("content-type",
                headers.getOrDefault("Content-Type", ""));

        if (contentType.contains("application/json")) {
            try {
                Object json = objectMapper.readValue(bodyBytes, Object.class);
                return ResponseBody.builder().mode(BodyMode.JSON).json(json).build();
            } catch (Exception e) {
                log.debug("Failed to parse JSON: {}", e.getMessage());
            }
        }

        if (contentType.contains("text/") || contentType.contains("application/xml")) {
            return ResponseBody.builder()
                    .mode(BodyMode.TEXT)
                    .text(new String(bodyBytes, StandardCharsets.UTF_8))
                    .build();
        }

        return ResponseBody.builder()
                .mode(BodyMode.BASE64)
                .base64(Base64.getEncoder().encodeToString(bodyBytes))
                .build();
    }

    // -------------------------------------------------------------------------
    // Helpers
    // -------------------------------------------------------------------------

    private void validateRequest(ApiConfig api) {
        securityService.validateUrl(api.getUrl());
        securityService.validateMethod(api.getMethod());
    }

    private boolean isBodylessMethod(ApiConfig.HttpMethod method) {
        return method == ApiConfig.HttpMethod.GET ||
               method == ApiConfig.HttpMethod.HEAD ||
               method == ApiConfig.HttpMethod.OPTIONS;
    }

    private String resolveCorrelationId(ActionRequest request) {
        if (request.getRequest() != null && StringUtils.hasText(request.getRequest().getCorrelationId())) {
            return request.getRequest().getCorrelationId();
        }
        return UUID.randomUUID().toString();
    }

    private String urlEncode(String value) {
        return URLEncoder.encode(value, StandardCharsets.UTF_8);
    }

    private Mono<ActionResponse> handleDryRun(String requestId, String correlationId) {
        return Mono.just(ActionResponse.builder()
                .requestId(requestId)
                .timestamp(Instant.now())
                .success(true)
                .correlationId(correlationId)
                .tokenCall(TokenCallInfo.builder().used(false).build())
                .rawResponse(RawResponse.builder()
                        .status(0)
                        .body(ResponseBody.builder()
                                .mode(BodyMode.TEXT)
                                .text("DRY_RUN - Request validated successfully")
                                .build())
                        .build())
                .metrics(Metrics.builder().durationMs(0).build())
                .build());
    }

    private ActionResponse buildResponse(String requestId, String correlationId, long startTime,
                                          TokenCallInfo tokenCall, RawResponse rawResponse,
                                          ActionRequest request, long tokenFetchMs,
                                          long bytesSent, long bytesReceived) {
        Map<String, Object> parsedOutput = new HashMap<>();

        if (request.getResponseHandling() != null && request.getResponseHandling().isParse()) {
            String bodyText = extractBodyText(rawResponse);
            parsedOutput = extractionService.extract(
                    request.getResponseHandling(),
                    rawResponse.getStatus(),
                    rawResponse.getHeaders(),
                    bodyText);
        }

        long totalDuration = System.currentTimeMillis() - startTime;

        return ActionResponse.builder()
                .requestId(requestId)
                .timestamp(Instant.now())
                .success(true)
                .correlationId(correlationId)
                .tokenCall(tokenCall)
                .rawResponse(rawResponse)
                .parsedOutput(parsedOutput.isEmpty() ? null : parsedOutput)
                .metrics(Metrics.builder()
                        .durationMs(totalDuration)
                        .tokenFetchMs(tokenFetchMs > 0 ? tokenFetchMs : null)
                        .targetCallMs(totalDuration - tokenFetchMs)
                        .bytesSent(bytesSent)
                        .bytesReceived(bytesReceived)
                        .build())
                .build();
    }

    private String extractBodyText(RawResponse rawResponse) {
        if (rawResponse.getBody() == null) return null;
        ResponseBody body = rawResponse.getBody();
        if (body.getJson() != null) {
            try { return objectMapper.writeValueAsString(body.getJson()); }
            catch (JsonProcessingException e) { return null; }
        }
        return body.getText();
    }

    private Mono<ActionResponse> handleError(String requestId, String correlationId,
                                              long startTime, Throwable ex) {
        log.error("[HttpClient] Action execution failed: {}", ex.getMessage());
        String code = ex instanceof ActionException ae ? ae.getCode() : "EXECUTION_FAILED";

        return Mono.just(ActionResponse.builder()
                .requestId(requestId)
                .timestamp(Instant.now())
                .success(false)
                .correlationId(correlationId)
                .error(ErrorInfo.builder().code(code).message(ex.getMessage()).build())
                .metrics(Metrics.builder()
                        .durationMs(System.currentTimeMillis() - startTime)
                        .build())
                .build());
    }
}
